\documentclass{article}
\usepackage[latin2]{inputenc}
\usepackage[czech]{babel}
\usepackage{a4wide}
\usepackage{url}
\author{Ale¹ Hakl\footnote{\texttt{hakla1@fel.cvut.cz}}}
\title{\texttt{ncc} - Kompilátor do LLVM IR}

\begin{document}
\maketitle

\section{Úvod}

Rozhodl jsem se, ¾e jako semestrální práci naprogramuji kompilátor
podmno¾iny jazyka C do vnitøní reprezentace pou¾ívané knihovnou
LLVM\cite{llvm}. Mojí hlavní motivací bylo vyzkou¹et, jak se tato knihovna
vlastnì pou¾ívá, a je-li ji mo¾né pou¾ít pro dynamické generování
kódu v mém projektu\cite{dfsch}. Závìry z tohoto pokusu jsou celkem
rozporuplné.

\section{Pou¾ití}

Program \texttt{ncc} naèítá kód ze souboru, jeho¾ jméno je uvedeno
na pøíkazové øádce. Po jeho naètení umí v závislosti na pøedaných
volbách pøíkazové øádky provést tøi rùzné operace (èi jejich
libovolnou kombinaci):

\begin{itemize}
  \item Vypsat abstraktní syntaktický strom na chybový výstup v
    pøípadì pou¾ití volby \texttt{--dump-ast}
  \item Vypsat textovou formu vnitøní reprezentace programu na chybový
    výstup (\texttt{--dump-ir})
  \item Zavolat funkci main() definovanou v zadaném
    programu. (\texttt{--run}) 
\end{itemize}


\section{Vstupní jazyk}
Jak u¾ jsem zmínil, vstupem mého kompilátoru je podmno¾ina jazyka
C\cite{isoc}. Obsahuje:
\begin{itemize}
  \item Èíselné typy \texttt{int} a \texttt{float}\footnote{který je
    pøeveden na datový typ \texttt{double}, nicménì pova¾uji za
    matoucí, aby se jediný podporovaný FP typ jmenoval
    \texttt{double}}
  \item Neprùhledný typ \texttt{ptr} podobný typu \texttt{void *} z C,
    se kterým nelze provádìt ¾ádné jiné operace ne¾ pøedání funkci
    jako parametr
  \item Øídící struktury \texttt{if}, \texttt{while}
  \item Logické operátory se zkráceným vyhodnocováním
  \item Globální a lokální promìnné
  \item Deklarace funkcí
  \item Prakticky v¹echny aritmetické operátory ze standardního C s
    výjimkou pøiøazovacích
  \item Relaèní operátory
  \item Ternární operátor
\end{itemize}

Vstupní soubor obsahuje posloupnost deklarací funkcí a promìnných a definicí 
funkcí (v libovolném poøadí).

\begin{verbatim}
input-file ::= top-level*
top-level ::= variable-declaration | function-declaration | function-definition
variable-declaration ::= type identifier ';'
function-declaration ::= function-prototype ';'
function-definition ::= function-prototype block
function-prototype ::= type identifier 
                       '(' ( type identifier ( ',' type identifier)* )? ')'
\end{verbatim}

Blok je posloupností pøíkazù, pøièem¾ za pøíkaz je pova¾ována i
definice lokální promìnné\footnote{tedy to co ISO C99 nazývá
  \textit{block-item}}.

\begin{verbatim}
block ::= '{' statement* '}'
statement ::= local-variable | block | return-statement | 
              if-statement | while-statement | comma-expression ';'
\end{verbatim}

Pøíkazy \texttt{if}, \texttt{while} a \texttt{return} odpovídají
shodným konstrukcím jazyka C\footnote{s výjimkou faktu, ¾e definice
  lokální promìnné je také platným pøíkazem, co¾ je ov¹em pro
  programátora nezajímavé, pouze to ponìkud zjednodu¹uje definici
  jazyka a implementaci parseru}.

\begin{verbatim}
if-statement ::= 'if' '(' comma-expression ')' statement 
                 ('else' statement)?
while-statement ::= 'while' '(' comma-expression ')' statement
return-statement ::= 'return' comma-expression ';'
\end{verbatim}

Syntaxe výrazù odpovídá s výjimkou vypu¹tìných operátorù syntaxi
jazyka C a nepova¾uji za úèelné ji zde uvádìt kompletní. Podporované
operátory jsou: \texttt{+}, \texttt{*}, \texttt{-}, \texttt{/},
\texttt{\&}, \texttt{|}, \texttt{\^}, \texttt{==}, \texttt{!=},
\texttt{<}, \texttt{>}, \texttt{<=}, \texttt{>=}, \texttt{,},
\texttt{\&\&}, \texttt{||}, \texttt{=}, unární \texttt{-}, \texttt{\~},
\texttt{!} a koneènì ternární operátor \texttt{?:}. Jediná podporovaná
l-hodnota je promìnná, na levé stranì pøiøazovacího výrazu tedy smí
stát pouze ta.

Definice lokální promìnné umo¾òuje její inicializaci zadaným výrazem,
na rozdíl od C nesmí tento výraz zaèínat pøiøazením.

\begin{verbatim}
local-variable ::= type IDENTIFIER ( '=' ternary-expression )?';'
\end{verbatim}

Jsou podporovány pouze tøi vý¹e zmínìné skalární typy:

\begin{verbatim}
type ::= 'int' | 'float' | 'ptr'
\end{verbatim}

\section{Implementaèní poznámky}
Program je psán pro verzi 2.2 knihovny LLVM. Aktuální verze (2.4)
obsahuje celkem zásadní nekompatibility a tudí¾ není bez úprav
pou¾itelná. Problém je, ¾e charakter tìchto nekompatibilit je takový,
¾e zmínìných zmìn je obrovské mno¾ství a prakticky v¹echny jsou pouze formálního
charakteru (pøejmenování tøíd, metod a podobnì). 

Bìhem pøekladu je program nejprve pøeveden do abstraktního
syntaktického stromu, který je poté rekurzivnì pøeveden na LLVM
IR. Tento AST v sobì pro jednoduchost neuchovává informaci o èíslech
øádek, chyby objevené a¾ v této fázi tudí¾ tuto informaci také
nenesou.

Pro tvorbu LLVM IR je pou¾ita tøída
\texttt{LLVMBuilder}\footnote{Která je bohu¾el v aktuální verzi LLVM
  pøejmenována na \texttt{IRBuilder}}. Tato tøída umo¾òuje vytváøet
mezikód podobným zpùsobem jako by se vytváøel obyèejný assembler.

Mechanizmus, kterým se pøedává informace o typu podvýrazu, není zcela
optimální, nicménì pro dané úèely dostaèuje. Lze pøedpokládat, ¾e
rozumnìj¹í cestou by bylo vyu¾ít faktu, ¾e informaci o typu hodnoty si
udr¾uje samotné LLVM a vyu¾ít tu a nikoli duplicitní
mechanismus. Výhodou pou¾itého øe¹ení je, ¾e je na první pohled
zøejmìj¹í.

Parser umí naèítat nìkteré konstrukce (napøíklad inicializátory
globálních promìnných nebo øetìzcové literály), pro které generátor
kódu neumí vytvoøit odpovídající kód. Tento jev pova¾uji za vlastnost,
proto¾e umo¾òuje v budoucnosti snadno generátor o danou funkènost
roz¹íøit\footnote{Pravdìpodobnì pøi pøechodu na novìj¹í verzi LLVM}.

K zpracování voleb pøíkazové øádky je pou¾ita tøída
\texttt{CommandOptions} od Ole Laursena\cite{cmdopts}. Verze pøilo¾ená
ke zdrojovému kódu obsahuje nìkolik mých roz¹íøení, ty ov¹em tento
program nepou¾ívá.

\section{Závìr}

I pøes nìkteré nedodìlky pracuje kompilátor vcelku dobøe. Ohlednì
uspoøádání zdrojového kódu je ponìkud nevhodné kombinovat abstraktní
syntaktický strom s generátorem kódu, ov¹em v C++ by bylo neúmìrnì
slo¾ité tyto èásti oddìlovat, zvlá¹» vzhledem k úèelu programu. 

Bohu¾el mì implementace tohoto jednoduchého kompilátoru pøesvìdèila,
¾e knihovna LLVM není pro moje úèely uplnì vhodná. To je z èásti i
dùvod, proè jsem nakonec nìkteré vlastnosti, které jsem pùvodnì
zamý¹lel, nedotáhl úplnì do konce.

\begin{thebibliography}{9}
  \bibitem{llvm} \textsl{The LLVM Compiler Infrastructure}
    \url{http://llvm.org/} 
  \bibitem{dfsch} Ale¹ Hakl \textsl{dfsch - Scheme-like dialect of
    LISP} \url{http://hakl.net/software/dfsch/}
  \bibitem{isoc} \textsl{ISO/IEC 9899:TC2 Programming languages - C}
  \bibitem{cmdopts} Ole Laursen \textsl{Command-line library} 
    \url{http://people.iola.dk/olau/commandoptions/}
\end{thebibliography}

\end{document}
